# Copyright 2013, mm1352000

# This file is part of NzSatEpg.

# NzSatEpg is free software: you can redistribute it and/or modify it under the
# terms of the GNU Affero Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.

# NzSatEpg is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero Public License for more details.

# You should have received a copy of the GNU Affero Public License along with
# NzSatEpg. If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;

package XmlTv::NzSatEpg::Channels::Inspiration;

use DateTime;
use PdfSupport::Core qw(setDebugStream setTextHandler readPage);
use String::Similarity;


my $grid = [];
my $vLines = [];
my $hLines = [];
my $progInfo = {};
my %progMatches = (
    # Hard-coded matches that are difficult to match automatically.
    'Campmeeting' => 'Inspiration Campmeeting Worship'
    , 'Creflo Dollar' => 'Creflo Dollar Ministries with Creflo Dollar'
    , 'David Jeremiah' => 'Turning Point with Dr. David Jeremiah'
);
my $referenceAestDate = DateTime->today(time_zone => 'Australia/Sydney');

sub round {

    my @toReturn = ();
    foreach my $num (@_) {
        push(@toReturn, sprintf("%.1f", $num));
    }
    return @toReturn;
}

sub checkPath {

    my ($segRef, $isClosed, $isClipping) = @_;

    # Unclosed path - not expected.
    if (!$isClosed) {
        print $::dbg "INI: Warning, unclosed path.\n";
        return 0;
    }

    # Clipping - ignored.
    if ($isClipping) {
        # We get quite a few of these. They don't seem to be a problem.
        #print $::dbg "INI: Warning, clipping path.\n";
        return 0;
    }

    # Path that isn't a quadrilateral - not expected.
    if (scalar(@$segRef) != 4) {
        print $::dbg "INI: Warning, path with " . scalar(@$segRef) . " line segments.\n";
        return 0;
    }

    # All lines are assumed to be straight and non-diagonal.
    foreach my $s (@$segRef) {
        if (($s->{'x1'} != $s->{'x2'}) && ($s->{'y1'} != $s->{'y2'})) {
            print $::dbg "INI: Warning, diagonal line in path.\n";
            return 0;
        }
        if ($s->{'isStraight'} != 1) {
            print $::dbg "INI: Warning, curved line in path.\n";
            return 0;
        }
    }

    return 1;
}

sub getPathCorners {

    my ($segRef, $ctmRef) = @_;

    # Get two corners of the path.
    my $point1 = PdfSupport::Core::matrixMultiply([1, 0, 0, 1, $segRef->[3]{'x1'}, $segRef->[3]{'y1'}], $ctmRef);
    my $point2 = PdfSupport::Core::matrixMultiply([1, 0, 0, 1, $segRef->[1]{'x1'}, $segRef->[1]{'y1'}], $ctmRef);

    # Make sure we've got the upper left and bottom right corners. If this path was generated by
    # 're' then we'll already have what we need.
    if ($point1->[4] > $point2->[4]) {
        my $tempX = $point1->[4];
        $point1->[4] = $point2->[4];
        $point2->[4] = $tempX;
    }
    if ($point1->[5] < $point2->[5]) {
        my $tempY = $point1->[5];
        $point1->[5] = $point2->[5];
        $point2->[5] = $tempY;
    }

    # We have to reduce the precision of points as sometimes the additional precision causes
    # issues when it comes to reconstructing the grid and order and positioning of text fragments.
    ($point1->[4], $point1->[5], $point2->[4], $point2->[5]) = round($point1->[4], $point1->[5], $point2->[4], $point2->[5]);

    return ($point1, $point2);
}

sub gridLineFinder {

    my ($segRef, $isClosed, $isStroked, $isFilled, $isClipping, $gstateRef) = @_;

    # We're looking for squares and rectangles that are drawn (ie. not clipping).
    return if (!checkPath($segRef, $isClosed, $isClipping));
 
    # Stroked path - this could indicate change of format.
    if ($isStroked) {
        print $::dbg "INI: Warning, stroked path.\n";
        return;
    }

    # Get the upper left and lower right corners of the path.
    my ($pointUl, $pointLr) = getPathCorners($segRef, $gstateRef->{'CTM'});
    my $xDiff = $pointLr->[4] - $pointUl->[4];
    my $yDiff = $pointUl->[5] - $pointLr->[5];

    # Lines are expressed as filled rectangles.
    if ($xDiff < 1 xor $yDiff < 1) {
        # Colour - expected to be pitch black.
        foreach my $c (@{$gstateRef->{'nonstroking'}{'colour'}}) {
            if ($c != 0) {
                print $::dbg "INI: Found non-black line:\n";
                print $::dbg "   Point UL = ($pointUl->[4], $pointUl->[5])\n";
                print $::dbg "   Point LR = ($pointLr->[4], $pointLr->[5])\n";
                print $::dbg "   Diffs = $xDiff, $yDiff\n\n";
                return;
            }
        }

        # Vertical line...
        if ($xDiff < 1) {
            my $found = 0;
            foreach my $vl (@$vLines) {
                if ($pointUl->[4] > $vl->[0] - 5 && $pointLr->[4] < $vl->[1] + 5) {
                    $found = 1;
                    if ($pointUl->[4] < $vl->[0]) {
                        $vl->[0] = $pointUl->[4];
                    }
                    if ($pointLr->[4] > $vl->[1]) {
                        $vl->[1] = $pointLr->[4];
                    }
                    last;
                }
            }
            if (!$found) {
                push(@$vLines, [$pointUl->[4], $pointLr->[4]]);
            }
        }

        # Horizontal line...
        elsif ($yDiff < 1) {
            my $found = 0;
            foreach my $hl (@$hLines) {
                if ($pointLr->[5] > $hl->[0] - 5 && $pointUl->[5] < $hl->[1] + 5) {
                    $found = 1;
                    if ($pointLr->[5] < $hl->[0]) {
                        $hl->[0] = $pointLr->[5];
                    }
                    if ($pointUl->[5] > $hl->[1]) {
                        $hl->[1] = $pointUl->[5];
                    }
                    last;
                }
            }
            if (!$found) {
                push(@$hLines, [$pointLr->[5], $pointUl->[5]]);
            }
        }
    }
    else {
        # These are the colour blocks. They are not relevant.
        #print $::dbg "INI: Found colour block:
        #print $::dbg "   Point UL = ($pointUl->[4], $pointUl->[5])\n";
        #print $::dbg "   Point LR = ($pointLr->[4], $pointLr->[5])\n\n";
    }
}

sub referenceDateFinder {

    my ($text, $ref) = @_;

    if ($text =~ m/^\s*(.+)\s+PROGRAMME\s+SCHEDULE\s*$/) {
        my $monthName = substr($1, 0, 1) . lc(substr($1, 1));
        print $::dbg "INI: Reference month is $monthName.\n";
        #$referenceAestDate->set(month => $::monthMap{$monthName});
    }
    elsif ($text =~ m/^\s*Mon\s+(\d+)\/(\d+).*/) {
        print $::dbg "INI: Reference day is $2.\n";
        $referenceAestDate->set(month => $1, day => $2);
    }
}

sub getVerticalLineRange {

    my $y1 = shift;
    my $y2 = shift;

    # Note: y1 is expected to be greater than y2. In other words, y1 to y2 is top to bottom.

    # Is the line within the grid?
    if (
        # Note: this condition is careful to exclude lines that only touch the grid but include the
        # lines that form the border of the grid.
        (
            $y2 > $hLines->[0][0]
            && ($y1 - $y2) > 1
        )
        || $y1 < $hLines->[$#{$hLines}][0]
    ) {
        # This happens with the lines that define the boundaries of the time column and headers.
        #print $::dbg "INI: Found line outside vertical grid boundaries:\n";
        #print $::dbg "   y1 = $y1\n";
        #print $::dbg "   y2 = $y2\n\n";
        return (-1, -1);
    }

    # Find the index of the row immediately below the start of the line.
    my $gridY1 = 0;
    while ($gridY1 < scalar(@{$hLines}) && $y1 < $hLines->[$gridY1][0]) {
        $gridY1++;
    }

    # Find the index of the row immediately above the end of the line.
    my $gridY2 = $gridY1;
    while ($gridY2 < $#{$hLines} && ($y2 < $hLines->[$gridY2 + 1][0])) {
        $gridY2++;
    }
    return ($gridY1, $gridY2);
}

sub getHorizontalLineRange {

    my ($x1, $x2) = @_;

    # Note: x1 is expected to be less than x2. In other words, x1 to x2 is left to right.

    # Is the line within the grid?
    if (
        # Note: this condition is careful to exclude lines that only touch the grid but include the
        # lines that form the border of the grid.
        (
            $x2 <= $vLines->[0][1]
            && ($x2 - $x1) > 1
        )
        || $x1 > $vLines->[$#{$vLines}][1]
    ) {
        # This happens with the lines that define the boundaries of the time column and headers.
        #print $::dbg "INI: Found line outside horizontal grid boundaries:\n";
        #print $::dbg "   x1 = $x1\n";
        #print $::dbg "   x2 = $x2\n\n";
        return (-1, -1);
    }

    # Find the index of the column immediately to the right of the start of the line.
    my $gridX1 = 0;
    while ($gridX1 < scalar(@{$vLines}) && $x1 > $vLines->[$gridX1][1]) {
        $gridX1++;
    }

    # Find the index of the column immediately to the left of the end of the line.
    my $gridX2 = $gridX1;
    while ($gridX2 < $#{$vLines} && ($x2 > $vLines->[$gridX2 + 1][1])) {
        $gridX2++;
    }
    return ($gridX1, $gridX2);
}

sub gridBuilder {

    my ($segRef, $isClosed, $isStroked, $isFilled, $isClipping, $gstateRef) = @_;

    # We're looking for squares and rectangles that are drawn (ie. not clipping).
    return if (!checkPath($segRef, $isClosed, $isClipping));

    # Stroked path - this could indicate change of format.
    if ($isStroked) {
        print $::dbg "INI: Warning, stroked path.\n";
        return;
    }

    # Get the upper left and lower right corners of the path.
    my ($pointUl, $pointLr) = getPathCorners($segRef, $gstateRef->{'CTM'});
    my $xDiff = $pointLr->[4] - $pointUl->[4];
    my $yDiff = $pointUl->[5] - $pointLr->[5];

    # Lines are expressed as filled rectangles.
    if ($xDiff < 1 xor $yDiff < 1) {
        # Colour - expected to be pitch black.
        foreach my $c (@{$gstateRef->{'nonstroking'}{'colour'}}) {
            if ($c != 0) {
                print $::dbg "Non-black line:\n";
                print $::dbg "   Point UL = ($pointUl->[4], $pointUl->[5])\n";
                print $::dbg "   Point LR = ($pointLr->[4], $pointLr->[5])\n";
                print $::dbg "   Diffs = $xDiff, $yDiff\n\n";
                return;
            }
        }

        # Find the index of the cell on the right of the line.
        my ($x1, $x2) = getHorizontalLineRange($pointUl->[4], $pointLr->[4]);
        return if ($x1 == -1);

        # Find the grid cell indices of the vertical limits of the line.
        my ($y1, $y2) = getVerticalLineRange($pointUl->[5], $pointLr->[5]);
        return if ($y1 == -1);

        # Vertical line...
        if ($xDiff < 1) {
            # For each cell that the line borders with...
            foreach my $y ($y1..$y2) {
                # The line is the left border of cells on its right.
                if (!defined $grid->[$x1]) {
                    $grid->[$x1] = [];
                }
                if (!defined $grid->[$x1][$y]) {
                    $grid->[$x1][$y] = {
                        'left' => 0
                        , 'right' => 0
                        , 'top' => 0
                        , 'bottom' => 0
                        , 'text' => {}
                    };
                }
                $grid->[$x1][$y]{'left'} = 1;

                # The line is the right border of cells on its left.
                if ($x1 != 0) {
                    if (!defined $grid->[$x1 - 1]) {
                        $grid->[$x1 - 1] = [];
                    }
                    if (!defined $grid->[$x1 - 1][$y]) {
                        $grid->[$x1 - 1][$y] = {
                            'left' => 0
                            , 'right' => 0
                            , 'top' => 0
                            , 'bottom' => 0
                            , 'text' => {}
                        };
                    }
                    $grid->[$x1 - 1][$y]{'right'} = 1;
                }
            }
        }

        # Horizontal line...
        elsif ($yDiff < 1) {
            # For each cell that the line borders with...
            foreach my $x ($x1..$x2) {
                # The line is the top border of cells directly below it.
                if (!defined $grid->[$x]) {
                    $grid->[$x] = [];
                }
                if (!defined $grid->[$x][$y1]) {
                    $grid->[$x][$y1] = {
                        'left' => 0
                        , 'right' => 0
                        , 'top' => 0
                        , 'bottom' => 0
                        , 'text' => {}
                    };
                }
                $grid->[$x][$y1]{'top'} = 1;

                # The line is the bottom border of cells directly above it.
                if ($y1 != 0) {
                    if (!defined $grid->[$x][$y1 - 1]) {
                        $grid->[$x][$y1 - 1] = {
                            'left' => 0
                            , 'right' => 0
                            , 'top' => 0
                            , 'bottom' => 0
                            , 'text' => {}
                        };
                    }
                    $grid->[$x][$y1 - 1]{'bottom'} = 1;
                }
            }
        }
    }
    else {
        # These are the colour blocks. They are not relevant.
        #print $::dbg "INI: Found colour block:
        #print $::dbg "   Point UL = ($pointUl->[4], $pointUl->[5])\n";
        #print $::dbg "   Point LR = ($pointLr->[4], $pointLr->[5])\n\n";
    }
}

sub scheduleInterpreter {

    my ($text, $ref) = @_;

    my ($x1, $x2, $y1, $y2, $width, $height) = round($ref->[4], $ref->[4] + $ref->[0], $ref->[5], $ref->[5] + $ref->[3], $ref->[0], $ref->[3]);

    if ($width == 0) {
        # Vertical text is not expected.
        print $::dbg "INI: Warning, vertical text \"$text\".\n";
        return;
    }

    # Is the text within the grid boundaries?
    if (
        $x1 < $vLines->[0][0]
        || $x1 > $vLines->[$#{$vLines}][1]
        || $y2 > $hLines->[0][1]
        || $y2 < $hLines->[$#{$hLines}][0]
    ) {
        return;
    }

    # Find the centre point of the text.
    my ($centreX, $centreY) = round($x1 + ($width / 2), $y1 + ($height / 2));

    # Find the corresponding grid cell.
    my ($gridX, $gridY) = (0, 0);
    while ($gridX < $#{$vLines} && $centreX > $vLines->[$gridX + 1][1]) {
        $gridX++;
    }
    while ($gridY < $#{$hLines} && $centreY < $hLines->[$gridY + 1][0]) {
        $gridY++;
    }

    # Record the text in the central cell.
    my $cell = $grid->[$gridX][$gridY];
    $cell->{'text'}{$y1}{$x1} = $text;

    my $expandedVertically = 0;
    my $expandedHorizontally = 0;

    # Spread to the left...
    my ($x, $y) = ($gridX, $gridY);
    while ($grid->[$x][$gridY]{'left'} == 0 && $x > 0) {
        $x--;
        $grid->[$x][$gridY]{'text'}{$y1}{$x1} = $text;
        $expandedHorizontally = 1;
    }
    $x = $gridX;

    # Spread to the right...
    while ($grid->[$x][$gridY]{'right'} == 0 && $x < $#{$vLines}) {
        $x++;
        $grid->[$x][$gridY]{'text'}{$y1}{$x1} = $text;
        $expandedHorizontally = 1;
    }
    $x = $gridX;

    # Spread upwards...
    while ($grid->[$gridX][$y]{'top'} == 0 && $y > 0) {
        $y--;
        $grid->[$gridX][$y]{'text'}{$y1}{$x1} = $text;
        $expandedVertically = 1;
    }
    $y = $gridY;

    # Spread downwards...
    while ($grid->[$gridX][$y]{'bottom'} == 0 && $y < $#{$hLines}) {
        $y++;
        $grid->[$gridX][$y]{'text'}{$y1}{$x1} = $text;
        $expandedVertically = 1;
    }

    if ($expandedVertically && $expandedHorizontally) {
        print $::dbg 'INI (' . __LINE__ . "): Text '$text' ($gridX, $gridY) was spread both vertically and horizontally.\n";
    }
}

sub getChannelData {

    print $::dbg "INI: Starting data grab...\n";

    print $::dbg "INI: Grabbing programme info...\n";
    my $response;
    my $categoryMenu;

    # Start with the "ministry" programmes.
    my $i = 1;
    while (1) {
        # Note the missing hyphen in the URL for the first page. Bit of a hack.
        $response = ($i == 1) ? $::wua->get("http://www.ini.tv/ministries/ministries-listings$i/") : $::wua->get("http://www.ini.tv/ministries/ministries-listings-$i/");
        if ($response->is_error()) {
            if ($i == 1) {
                print $::dbg 'INI (' . __LINE__ . "): The request for ministry description page $i HTML failed. " . $response->status_line() . "\n";
            }
            last;
        }
        if ($i == 1) {
            $response->content =~ m/.*?<li\s+id="menu-item-191"(.*?)<\/ul>.*/s;
            $categoryMenu = $1;
        }

        if ($response->content =~ m/.*?<div\s+class="entry\-content">\s*<table[^>]*>(.*?)<\/table>.*/s) {
            my $content = $1;
            $content =~ s/<strong>//g;
            $content =~ s/<\/strong>/<br \/>/g;
            while ($content =~ m/.*?<tr>\s*<td>.*?\s*([^<>]*?)(\s*<br\s*\/>\s*)+(.*?)\s*<\/td>(.*)/s) {
                $progInfo->{$1} = { 'description' => $3 };
                $content = $4;
            }
        }
        else {
            last;
        }
        $i++;
    }

    # Follow up with the categorised programmes.
    while ($categoryMenu =~ m/.*?<li.*?<a\s+href="([^"]+)">\s*(.*?)\s*<\/a>(.*)/s) {
        my ($url, $category) = ($1, $2);
        $categoryMenu = $3;

        $response = $::wua->get($url);
        if ($response->is_error()) {
            print $::dbg 'INI (' . __LINE__ . "): The request for the $category description page HTML failed. " . $response->status_line() . "\n";
        }
        elsif ($response->content =~ m/.*?<div\s+class="entry\-content">\s*<table[^>]*>(.*?)<\/table>.*/s) {
            my $content = $1;
            $content =~ s/<strong>//g;
            $content =~ s/<\/strong>//g;
            while ($content =~ m/.*?<tr>\s*<td>.*?([^<>]*?)\s*<br\s*\/.*?>\s*([^<>]+?)\s*<\/td>(.*)/s) {
                $progInfo->{$1} = { 'description' => $2, 'category' => $category };
                $content = $3;
            }
        }
    }

    # INI only provides their schedule as a PDF... which makes getting the data a little tricky!

    # First grab their schedule page so that we can find the link(s) to their PDF file(s).
    print $::dbg "INI: Starting PDF download...\n";
    $response = $::wua->get('http://www.ini.tv/schedule/australia-listings/');
    if ($response->is_error()) {
        print $::dbg 'INI (' . __LINE__ . '): The request for the schedule page HTML failed. ' . $response->status_line() . "\n";
        return undef;
    }

    # Find the link and download the PDF.
    if ($response->content !~ m/.*?<a.*?href="([^"]*)"[^>]*>(<strong>)?Download PDF Schedule(<\/strong>)?<\/a>.*/s) {
        print $::dbg 'INI (' . __LINE__ . "): Failed to find the schedule PDF link.\n";
        return undef;
    }
    $response = $::wua->get($1);
    if ($response->is_error()) {
        print $::dbg 'INI (' . __LINE__ . "): Error downloading the schedule PDF from \"$1\". " . $response->status_line() . "\n";
        return undef;
    }
    if (!open(TEMP, ">$::tempPath\\INI.pdf")) {
        print $::dbg 'INI (' . __LINE__ . "): Failed to save the schedule PDF to disk.\n";
        return undef;
    }
    binmode(TEMP);
    print TEMP $response->content;
    close(TEMP);

    # PDF::API2 can't handle version 1.5+ cross reference streams. Unfortunately INI PDFs utilise
    # these streams. We use GhostScript to work around this issue; GS substitutes incompatible
    # stream features with version 1.4 compatible alternatives.
    my $convertResult = system('c:\Program Files\GhostScript 9.07\bin\gswin32.exe', '-sDEVICE=pdfwrite', '-dCompatibilityLevel=1.4', "-o \"$::tempPath\\INI-compatible.pdf\"", "\"$::tempPath\\INI.pdf\"");
    if ($convertResult) {
        print $::dbg 'INI (' . __LINE__ . "): GhostScript failed to convert the schedule PDF to a compatible format. The result code was $convertResult.\n";
        return undef;
    }

    # Read the PDF, page by page.
    print $::dbg "INI: Processing the schedule...\n";
    my $pdf = PdfSupport::Core->open("$::tempPath\\INI-compatible.pdf");
    if (!defined $pdf) {
        print $::dbg 'INI (' . __LINE__ . "): Failed to open the schedule PDF.\n";
        return undef;
    }

    # In the first pass we find the precise locations of the grid lines. We have to do this
    # because the grid can move around on the page and change size slightly from week to week.
    # We also determine the date associated with the first day of the schedule.
    $pdf->setPathHandler(\&gridLineFinder);
    $pdf->setTextHandler(\&referenceDateFinder);
    my $pageCount = $pdf->getPageCount();
    if ($pageCount != 1) {
        print $::dbg 'INI (' . __LINE__ . "): This PDF has $pageCount pages, but we only expected 1 page.\n";
        return undef;
    }
    $pdf->readPage(1);
    if ((scalar(@$vLines) != 9 && scalar(@$vLines) != 10) || scalar(@$hLines) != 51) {
        print $::dbg 'INI (' . __LINE__ . '): Unexpected grid format; ' . scalar(@$vLines) . ' vertical lines and ' . scalar(@$hLines) . " horizontal lines.\n";
        return undef;
    }

    # We throw away the vertical line(s) on the outside of the time column(s)...
    @$vLines = sort { $a->[0] <=> $b->[0] } @$vLines;
    @$vLines = @{$vLines}[1..8];

    # ...and the lines above the header and below the footer. The horizontal line sorting is from
    # top to bottom of the page (remember the origin is at the bottom left corner, so that is why
    # we reverse sort).
    @$hLines = sort { $b->[0] <=> $a->[0] } @$hLines;
    @$hLines = @{$hLines}[2..50];

    # In the second pass we are able to build a picture of the grid that enables us to identify
    # programmes that run for longer than half an hour. In other words, we look for merged cells.
    $pdf->setPathHandler(\&gridBuilder);
    $pdf->setTextHandler(undef);
    $pdf->readPage(1);

    # In the third and final pass we actually interpret the schedule data. Note that we have to set
    # the logical string separation because for some reason certain strings don't appear to be
    # separated properly. This does make the processing more compute intensive and harder to debug
    # (due to each character being processed separately), however we have no choice.
    $pdf->setPathHandler(undef);
    $pdf->setTextHandler(\&scheduleInterpreter);
    $pdf->readPage(1, 0, 0);

    my %schedule = ();
    my %prevProg = (
        'title' => ''
    );
    foreach my $x (0..$#{$vLines} - 1) {
        foreach my $y (0..$#{$hLines} - 1) {
            my $progTitle = '';
            my @textLines = sort { $b <=> $a } keys %{$grid->[$x][$y]{'text'}};
            foreach my $l (@textLines) {
                my @textLineFragments = sort { $a <=> $b } keys %{$grid->[$x][$y]{'text'}{$l}};
                foreach my $f (@textLineFragments) {
                    # Some titles are multi-line in the PDF. These titles don't actually include a
                    # space to separate the last word on the top line with the first word on the
                    # bottom line. We do that here. If the fragment starts with an upper-case
                    # letter...
                    my $t = $grid->[$x][$y]{'text'}{$l}{$f};
                    my $titleLength = length($progTitle);
                    if ($titleLength != 0 && substr($progTitle, $titleLength - 1) ne ' ' && substr($t, 0, 1) =~ m/[A-Z]/) {
                        $progTitle .= ' ';
                    }
                    $progTitle .= $grid->[$x][$y]{'text'}{$l}{$f};
                }
            }
            # Remove leading and trailing spaces from the programme title.
            $progTitle =~ m/^\s*(.*?)\s*$/;
            $progTitle = $1;

            next if ($progTitle eq $prevProg{'title'});

            my $time = $referenceAestDate->clone()->add(days => $x, minutes => 30 * $y)->set_time_zone($::targetTimeZone)->strftime('%Y%m%d%H%M');
            if (exists $prevProg{'start'}) {
                addProgramme(\%schedule, \%prevProg, $time);
            }

            %prevProg = (
                'title' => $progTitle
                , 'start' => $time
            );
        }
    }

    my $endTime = $referenceAestDate->clone()->add(days => ($#{$vLines} - 1), minutes => 30 * ($#{$hLines} - 1))->set_time_zone($::targetTimeZone)->strftime('%Y%m%d%H%M');
    addProgramme(\%schedule, \%prevProg, $endTime);

    return [
        {
            'id' => 'inspiration.optus_d2.xmltv.org'
            , 'name' => 'Inspiration'
            , 'url' => [
                'http://www.ini.tv/'
            ]
            , 'schedule' => \%schedule
        }
    ];
}

sub addProgramme {

    my ($schedule, $prog, $endTime) = @_;

    if ($endTime > $::startDate->strftime('%Y%m%d%H%M') && $prog->{'start'} < $::endDate->strftime('%Y%m%d%H%M')) {
        my $p = {
            'title' => $prog->{'title'}
            , 'start' => $prog->{'start'}
            , 'end' => $endTime
        };
        if ($prog->{'title'} =~ m/\s+with\s+(.*)/) {
            $p->{'host'} = [$1];
        }

        # Attempt to match a programme info set using the programme title.
        if (!exists $progMatches{$prog->{'title'}}) {
            $progMatches{$prog->{'title'}} = undef;

            my ($maxSim, $bestKey) = (0, '');
            foreach my $dk (keys %$progInfo) {
                my $sim = similarity($dk, $prog->{'title'});
                if ($sim > $maxSim) {
                    $maxSim = $sim;
                    $bestKey = $dk;
                }
            }

            # 0.6 is the magic matching threshold.
            if ($maxSim > 0.60) {
                #print $::dbg "INI: similarity match $maxSim, $prog->{'title'}  $bestKey\n";
                $progMatches{$prog->{'title'}} = $bestKey;
            }
        }
        if (defined $progMatches{$prog->{'title'}}) {
            my $dk = $progMatches{$prog->{'title'}};
            $p->{'description'} = $progInfo->{$dk}{'description'};
            if (exists $progInfo->{$dk}{'category'}) {
                $p->{'category'} = [$progInfo->{$dk}{'category'}];
            }
        }

        $schedule->{$prog->{'start'}} = $p;
    }
}

1;